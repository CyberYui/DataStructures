#include <iostream>
#include <stdlib.h>
#include "StackNSConversion.h"

using namespace std;

/*****************************************************************************/
/*	栈应用---数制转换														 */
/*																			 */
/*	描述:输入任意的十进制正整数N,分别输出该整数N的二进制,八进制,十六进制的数 */
/*																			 */
/*	公式:N = (N div d) * d + N mod d   (div=整除,mod==求余)					 */
/*																			 */
/*	(1348)(十进制) = (2504)(八进制) = (544)(十六进制) = (10101000100)(二进制)*/
/*																			 */
/*	短除法(八进制)															 */
/*																			 */
/*		N		N div 8		N mod 8											 */
/*	   1348		  168		   4										 	 */
/*	    168		   21		   0											 */
/*		 21			2		   5											 */
/*		  2			0		   2											 */
/*	   [注意]一旦商出现0就停止,对于余数从后往前读即获得进制数				 */
/*																			 */
/*	短除法(十六进制)														 */
/*																			 */
/*		N		 N div 16	   N mod 16										 */
/*	   1348		   84 			  4											 */
/*		 84		    5			  4											 */
/*		  5		    0			  5											 */
/*	   [注意]一旦商出现0就停止,对于余数从后往前读即获得进制数				 */
/*																			 */
/*	实验目的:通过此例灵活掌握栈机制的使用技巧								 */
/*																			 */
/*  创建日期:2019-03-11          Author:Cyber Kaka							 */
/*****************************************************************************/

//可见进制的读数就是把余数倒着读出来,且为后进先出,刚刚好可以用到栈
//即将每次求余的余数放进栈中,然后从栈顶依次遍历栈并输出即可

//定义一下进制,即宏定义出全局常量
#define BINARY		2
#define OCTONARY	8
#define HEXADECIMAL	16

int main(void)
{
	//完善:定义出一个数组,包含所有的字符
	char hexNumber[] = "0123456789ABCDEF";//不需要中间加逗号
	//也就是说如果对应的是数字,那就对应出数组的相应内容下标
	//如果是十六进制中大于9的数字,那么对应数组相应内容下标
	//显示数组的相应内容,就会打印出ABCDEF等字符

	MyStack<int> *pStack = new MyStack<int>(16);//主要看二进制的数
	//主要问题:
	//1.余数如何保存并push进栈
	//2.商如何迭代,因为并不知道会在哪一次得到商为0

	//对于商的迭代,可以用到while循环
	//while循环的好处是便于理解
	//int N = 1348;
	int N = 9645;//1348在十六进制下无法出现ABCD等字符
	int mod = 0;
	//对于不同的进制,只需要在循环中修改宏定义的标记即可
	while (N != 0)
	{
		mod = N % HEXADECIMAL;//八进制
		pStack->push(mod);//把余数放栈中
		N = N / HEXADECIMAL;//N变为除数
		//如此往复就完成了短除法的运算
	}
	//对于16进制,有ABCD等字母的显示,需要再进行程序完善
	//完善之后遍历方式就变化了,因为遍历需要对栈和数组进行
	//pStack->stackTraverse(false);

	//思路1.
	//可以考虑用循环,将栈中存入的数字作为hexNumber的索引
	//对hexNumber进行打印相应索引对应的数组元素
	//但是仅仅进行这样的使用是会报错的,所以要对索引运算符进行重载
	/*for (int i = pStack->stackLength()-1;i>=0;i--)
	{
		hexNumber[pStack[i]]
	}*/

	//思路2.
	//可以使用pop函数,一个一个地将栈中元素拿出来
	int elem = 0;//中间变量,用于取出从栈中拿出的元素
	while (!pStack->stackEmpty())
	{
		//如果为空,就停止循环,不为空,就一直循环
		pStack->pop(elem);
		cout << hexNumber[elem];//取出的栈元素作为下标,即可得到对应内容
	}
	cout << endl;


	delete pStack;
	pStack = NULL;

	system("pause");
	return 0;
}