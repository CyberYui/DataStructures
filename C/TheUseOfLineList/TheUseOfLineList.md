线性表的应用
==========
一元多项式的加法:
------------

1. 全部系数顺序存储结构

2. 非零系数顺序存储结构,必须同时存储相应的指数



3. 非零系数单链表存储结构

&emsp;&emsp;结点包括3部分:系数+指数+指针域

如何实现用有序链表表示的多项式的加法运算?
-------------
&emsp;&emsp;根据一元多项式相加的运算规则:
* 对于两个一元多项式中所有指数相同的项,对应系数相加;
* 若其和不为0,则构成和"多项式"中的一项;
* 对于两个一元多项式中所有指数不同的项,则分别复制到"和多项式"中去;

在有序链表中,就可以按这样的三步进行
如下图,有两个指针,一个指向pa多项式链表,另一个指向pb多项式链表

将pa多项式作为"和多项式"
//首先摘去第二个链表头结点,便于两表相连
//exponent n. 指数
(1)pa->exponent < pb->exponent;//对比两个结点的指数,若不同,则把小的先放到和多项式链表中
(2)pa->exponent == pb->exponent;//指数相同,则系数相加coefficient n.系数
   pa->coefficient + pb->coefficient;
   //这样得到的结果,如果不为0,则修改*pa的系数,然后释放*pb;
   //若为0,则删除*pa和*pb的系数,并释放两个结点;
(3)pa->exponent > pb->exponent;//对比两个结点的指数,若不同,则把小的先放到和多项式链表中
   //在这里,需要有前驱结点的指针域变化,应放入考虑范围内

[注]在进行时,pa后移,则其前面的部分链表就是"和多项式",其后的就是pa多项式
    最后,当*pa和*pb指向NULL时,算法结束

相关算法框架:
----------
主要涉及到的主要算法:
1. 建立多项式,并对输入的多项式进行升幂排序
2. 输出输入的多项式
3. 多项式的加法算法

```c
//多项式的加法
void AddPolyn(linklist *pa,linklist *pb)
{
    int x;//系数临时变量
    //设置跳过两个多项式头结点的指针
    DataType *p=pa->link;
    DataType *q=pb->link;
    while(p!-NULL && q!=NULL)
    {
        //没有空链表,开始对比指数
        if(p->exp == q->exp)
        {
            //系数相加
            x = p->coef + q->coef;
            if(x == 0)
            {
                //删除p当前结点
                //删除并释放q当前结点
            }
            else
            {
                //修改p当前结点的系数为x
                //p后移
                //删除并释放q的当前节点
                //q后移
            }
        }
        else
        {
            //将q当前结点插入到p中
            //修改p的前驱结点指针域
        }
    }
    //当有一个指针指向NULL时,循环会跳出来
    if(q!=NULL)
    {
        //将q的剩余结点加到和多项式中
    }
    //如果p!=NULL而q=NULL的话,p作为"和多项式",剩余的结点都可以不用动
    else
    {
        //do nothing
    }
}
```
流程图如下:
[流程图]

