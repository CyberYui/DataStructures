一个栈的入栈序列a，b，c，d，e，则栈的不可能的输出序列是（A）<br>
A:DCEAB<br>
B:ABCDE<br>
C:EDCBA<br>
D:DECBA<br>
[分析]<br>
堆栈讲究先进后出，后进先出<br>
选项A是错误的，不可能a先出栈<br>
选项B是a入栈，然后a出栈；b再入栈，b出栈。。。。。。依此类推<br>
选项C是abcde先入栈，然后依次出栈，正好是edcba<br>
选项D是abcd先依次入栈，然后d出栈，e再入栈，e出栈<br>
所以选A<br>

已知其头尾指针分别是front和rear，判定一个循环队列QU（最多元素为m）为空的条件是（A）<br>
A:QU->front == QU->rear<br>
B:QU->front != (QU->rear+1)%m<br>
C:QU->front == (QU->rear+1)%m<br>
D:QU->front != QU->rear<br>
[分析]<br>
头尾指针是一个的时候,即只有头结点,循环队列为空<br>
所以选A<br>

已知其头尾指针分别是front和rear，判定一个循环队列QU（最多元素为m）为满的条件是（C）<br>
A:QU->front == QU->rear<br>
B:QU->front != (QU->rear+1)%m<br>
C:QU->front == (QU->rear+1)%m<br>
D:QU->front != QU->rear<br>
[分析]<br>
少用一个元素空间，每次入队前测试入队后头尾指针是否会重合，如果会重合就认为队列已满<br>
这种情况下队满的条件是：(Q.rear+1)%MAXSIZE=Q.front，能和空队区别开。<br>
所以选C<br>

已知栈的最大容量为4。若进栈序列为1，2，3，4，5，6，且进栈和出栈可以穿插进行,则可能出现的出栈序列（D）<br>
A:5,4,3,2,1,6<br>
B:2,3,5,6,1,4<br>
C:1,4,6,5,2,3<br>
D:3,2,5,4,1,6<br>
[分析]<br>
同第一题,只有D有可能<br>
A中,栈最大容量为4;1,2,3,4进栈,4,3,2,1出栈,不可能出现5先出栈<br>
B中,栈最大容量为4;1,2进栈,2出栈,3进栈,3出栈,4,5,6进栈,最后是6,5,4,1出栈,不可能出现1,4<br>
C中,栈最大容量为4;1进栈,1出栈,2,3,4进栈,4出栈,5,6进栈,6,5,3,2出栈,不可能出现2,3<br>
D正确,栈最大容量为4;1,2,3进栈,3,2出栈,4,5进栈,5,4,1出栈,6进栈,6出栈<br>

设循环队列的元素存放在一维数组Q［0‥30］中，队列非空时，front指示队头元素的前一个位置，rear指示队尾元素。如果队列中元素的个数为11，front的值为25，则rear应指向的元素是（A）<br>
A:Q[5]<br>
B:Q[14]<br>
C:Q[15]<br>
D:Q[4]<br>
[分析]<br>
front指向队头元素的前一个位置,则25为对头前一个位置,故[26],[27],[28],[29],[30]是五个队列元素,<br>
数组从0开始数,所以[0],[1],[2],[3],[4],[5]为剩下的6个元素,最后一个队尾元素即Q[5]<br>

设栈S和队列Q的初始状态为空，元素1,2,3,4,5,6.依次通过栈S，一个元素出栈后即刻进入队列Q。若这6个元素出队列的顺序是2,4,3,6,5,1，则栈的容量至少应该是（A）<br>
A:3<br>
B:5<br>
C:4<br>
D:2<br>
[分析]<br>
如果栈容量为3;1,2入栈,2出栈,3,4入栈,4,3出栈,5,6入栈,6,5,1出栈,即得到结果<br>

有5个元素（a，b，c，d，e）按照先后次序压入栈中，进栈后可停留、可出栈，则栈混洗中以d开头的序列个数是（A）<br>
A:4<br>
B:5<br>
C:3<br>
D:6<br>
[分析]<br>
要d开头,至少要a,b,c,d入栈,剩个e,然后分情况讨论,主要看e的放置位置<br>
d出栈,e入栈,e,c,b,a出栈<br>
d,c出栈,e入栈,e,b,a出栈<br>
d,c,b出栈,e入栈,e,a出栈<br>
d,c,b,a出栈,e入栈,e出栈<br>
即四种情况<br>


设两个栈S1和S2共享同一空间数组a[0,1…MAX]，为了最大限度利用数组空间，两个栈采用相向增长的方式，top[1]是低端栈s1的栈顶指针，top[2]是高端栈s2的栈顶指针，则栈满的判断条件是（A）<br>
A:top[1]+1==top[2]<br>
B:top[2]==MAX<br>
C:top[1]==0<br>
D:top[1]==MAX<br>
[分析]<br>
设MAX=2,则top[1]=0,top[2]=2-1=1(因为数组从0开始数,给的max是空间个数2)<br>
栈满,即top[1]的下一个位置就是top[2],即两个顶到一起了,数字关系为top[1]+1==top[2]<br>

下面更合适表示队列的链表结构是（C）<br>
A:双向链表<br>
B:单向链表<br>
C:单向循环链表<br>
D:双向循环链表<br>
[分析]<br>
使用带有尾指针的单链表即可<br>

栈和队列的共同点是(C)<br>
A:都是先进先出<br>
B:没有共同点<br>
C:只允许在端点处插入和删除元素<br>
D:都是先进后出<br>
[分析]<br>
栈是先进后出的，队列是先进先出的，共同点是只允许在端点处插入和删除元素。栈都是在一端进与出，而队列是在一端进在另一端出。<br>

在计算机内实现递归算法时所需的辅助数据结构是(D)<br>
A:队列<br>
B:二叉树<br>
C:线性表<br>
D:栈<br>

一个递归的定义可以用递归过程求解，也可以用非递归过程求解，但单从运行空间效率来看，通常递归过程比非递归过程(D)<br>
A:节省空间(较快)<br>
B:相同(相同)<br>
C:不确定(无法确定)<br>
D:浪费空间(较慢)<br>
[分析]<br>
递归采用的是栈堆积的方式进行运算，每一次调用递归，内存都不断堆积，直到最后才求解，因此占用内存大，计算量成倍增加。所以递归过程较慢。<br>

下面哪种数据结构不是线性结构(C)<br>
A:栈<br>
B:线性表<br>
C:二叉树<br>
D:队列<br>
[分析]<br>
二叉树为树形结构<br>

在初始为空的栈中依次将元素f，e，d，c，b，a进栈之后，连续进行了三次出栈操作，则此时栈顶元素是(A)<br>
A:D<br>
B:F<br>
C:A<br>
D:C<br>
[分析]<br>
先进后出,所以三次出栈的是a,b,c<br>

一个递归算法必须包括(C)<br>
A:递归部分<br>
B:迭代部分<br>
C:终止条件和递归部分<br>
D:终止条件和迭代部分<br>

和顺序栈相比，链栈有一个明显的优势是(B)<br>
A:删除操作更容易实现<br>
B:通常不会出现栈满的情况<br>
C:通常不会出现栈空的情况<br>
D:插入删除更容易实现<br>


